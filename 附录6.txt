附录6 可视化与报告生成代码
"""
附录6: 数据可视化与报告生成模块

本模块提供了一系列用于数据可视化和自动报告生成的工具函数。
包括高级图表绘制、动态报告生成、LaTeX表格生成等功能。

作者: [团队成员姓名]
创建时间: 2025-08-03
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from typing import List, Dict, Union, Optional
import plotly.graph_objects as go
import plotly.express as px
from pathlib import Path
import jinja2
import markdown2
import json
from datetime import datetime

class VisualizationEngine:
    """高级数据可视化引擎
    
    提供了一系列专业的数据可视化方法，支持静态和交互式图表。
    包括科研论文级别的图表格式设置。
    
    属性:
        style: 图表风格设置
        color_palette: 配色方案
        font_family: 字体设置
    """
    
    def __init__(self,
                 style: str = 'scientific',
                 color_palette: str = 'colorblind',
                 font_family: str = 'Times New Roman'):
        """初始化可视化引擎
        
        Args:
            style: 图表风格，可选 'scientific'/'modern'/'classic'
            color_palette: 配色方案名称
            font_family: 字体名称
        """
        self.style = style
        self.color_palette = color_palette
        self.font_family = font_family
        
        # 设置全局样式
        plt.style.use('seaborn')
        sns.set_palette(color_palette)
        plt.rcParams['font.family'] = font_family
        
    def plot_optimization_progress(self,
                                 metrics: Dict[str, List[float]],
                                 save_path: Optional[str] = None):
        """绘制优化过程收敛曲线
        
        Args:
            metrics: 包含各项指标随代数变化的字典
            save_path: 图像保存路径
        """
        plt.figure(figsize=(12, 6))
        
        for metric_name, values in metrics.items():
            plt.plot(values, label=metric_name, linewidth=2)
            
        plt.xlabel('迭代次数')
        plt.ylabel('指标值')
        plt.title('优化算法收敛过程')
        plt.legend()
        plt.grid(True)
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        plt.close()
        
    def create_interactive_pareto_front(self,
                                      objectives: np.ndarray,
                                      pareto_front: np.ndarray,
                                      save_path: Optional[str] = None):
        """创建交互式Pareto前沿图
        
        使用Plotly生成可交互的3D散点图。
        
        Args:
            objectives: 所有解的目标函数值
            pareto_front: Pareto前沿解的目标函数值
            save_path: HTML文件保存路径
        """
        fig = go.Figure()
        
        # 添加所有解
        fig.add_trace(go.Scatter3d(
            x=objectives[:, 0],
            y=objectives[:, 1],
            z=objectives[:, 2],
            mode='markers',
            marker=dict(
                size=4,
                color='gray',
                opacity=0.6
            ),
            name='可行解'
        ))
        
        # 添加Pareto前沿
        fig.add_trace(go.Scatter3d(
            x=pareto_front[:, 0],
            y=pareto_front[:, 1],
            z=pareto_front[:, 2],
            mode='markers',
            marker=dict(
                size=6,
                color='red',
                opacity=0.8
            ),
            name='Pareto前沿'
        ))
        
        fig.update_layout(
            title='交互式三维Pareto前沿',
            scene=dict(
                xaxis_title='目标函数1',
                yaxis_title='目标函数2',
                zaxis_title='目标函数3'
            ),
            width=1000,
            height=800
        )
        
        if save_path:
            fig.write_html(save_path)
            
    def plot_sensitivity_analysis(self,
                                data: pd.DataFrame,
                                save_path: Optional[str] = None):
        """绘制敏感性分析图表
        
        创建参数敏感性分析的热力图和小提琴图。
        
        Args:
            data: 包含参数和响应值的DataFrame
            save_path: 图像保存路径
        """
        plt.figure(figsize=(15, 10))
        
        # 创建2x2的子图
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)
        
        # 1. 相关性热力图
        sns.heatmap(data.corr(), annot=True, cmap='RdYlBu', ax=ax1)
        ax1.set_title('参数相关性分析')
        
        # 2. 参数分布小提琴图
        sns.violinplot(data=data, ax=ax2)
        ax2.set_title('参数分布')
        ax2.tick_params(axis='x', rotation=45)
        
        # 3. 主效应图
        for column in data.columns[:-1]:  # 除去响应变量
            sns.regplot(x=column, y=data.columns[-1],
                       data=data, ax=ax3, label=column)
        ax3.set_title('参数主效应分析')
        ax3.legend()
        
        # 4. 残差分布图
        sns.histplot(data=data.columns[-1], ax=ax4)
        ax4.set_title('响应值分布')
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        plt.close()

class ReportGenerator:
    """自动报告生成器
    
    用于生成专业的技术报告，支持多种格式输出。
    包括LaTeX、Markdown和HTML格式。
    
    属性:
        template_dir: 报告模板目录
        output_dir: 输出目录
        metadata: 报告元数据
    """
    
    def __init__(self,
                 template_dir: str,
                 output_dir: str):
        """初始化报告生成器
        
        Args:
            template_dir: 报告模板目录路径
            output_dir: 报告输出目录路径
        """
        self.template_dir = Path(template_dir)
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # 初始化Jinja2模板引擎
        self.env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(str(self.template_dir))
        )
        
        # 初始化元数据
        self.metadata = {
            'title': '数学建模竞赛报告',
            'authors': [],
            'date': datetime.now().strftime('%Y-%m-%d'),
            'version': '1.0'
        }
        
    def set_metadata(self, metadata: Dict):
        """设置报告元数据
        
        Args:
            metadata: 包含报告元数据的字典
        """
        self.metadata.update(metadata)
        
    def generate_latex_report(self,
                            content: Dict,
                            template_name: str = 'report_template.tex',
                            output_name: str = 'report.tex'):
        """生成LaTeX格式报告
        
        Args:
            content: 报告内容字典
            template_name: LaTeX模板文件名
            output_name: 输出文件名
        """
        template = self.env.get_template(template_name)
        
        # 合并元数据和内容
        data = {**self.metadata, **content}
        
        # 渲染模板
        output = template.render(data)
        
        # 保存文件
        output_path = self.output_dir / output_name
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(output)
            
    def generate_markdown_report(self,
                               content: Dict,
                               template_name: str = 'report_template.md',
                               output_name: str = 'report.md'):
        """生成Markdown格式报告
        
        Args:
            content: 报告内容字典
            template_name: Markdown模板文件名
            output_name: 输出文件名
        """
        template = self.env.get_template(template_name)
        
        # 合并元数据和内容
        data = {**self.metadata, **content}
        
        # 渲染模板
        output = template.render(data)
        
        # 保存文件
        output_path = self.output_dir / output_name
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(output)
            
    def generate_html_report(self,
                           content: Dict,
                           template_name: str = 'report_template.html',
                           output_name: str = 'report.html'):
        """生成HTML格式报告
        
        Args:
            content: 报告内容字典
            template_name: HTML模板文件名
            output_name: 输出文件名
        """
        template = self.env.get_template(template_name)
        
        # 合并元数据和内容
        data = {**self.metadata, **content}
        
        # 渲染模板
        output = template.render(data)
        
        # 保存文件
        output_path = self.output_dir / output_name
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(output)
            
    def create_latex_tables(self,
                          data: pd.DataFrame,
                          caption: str,
                          label: str) -> str:
        """创建LaTeX格式表格
        
        将DataFrame转换为LaTeX表格代码。
        
        Args:
            data: 输入数据
            caption: 表格标题
            label: 表格标签
            
        Returns:
            str: LaTeX表格代码
        """
        latex_code = []
        
        # 表格环境开始
        latex_code.append('\\begin{table}[htbp]')
        latex_code.append('\\centering')
        latex_code.append(f'\\caption{{{caption}}}')
        latex_code.append(f'\\label{{{label}}}')
        
        # 确定列格式
        n_cols = len(data.columns)
        col_format = 'c'.join(['|'] * (n_cols + 1))
        latex_code.append(f'\\begin{{tabular}}{{{col_format}}}')
        latex_code.append('\\hline')
        
        # 添加表头
        header = ' & '.join(data.columns)
        latex_code.append(f'{header} \\\\')
        latex_code.append('\\hline')
        
        # 添加数据行
        for _, row in data.iterrows():
            row_str = ' & '.join(str(x) for x in row)
            latex_code.append(f'{row_str} \\\\')
            latex_code.append('\\hline')
            
        # 表格环境结束
        latex_code.append('\\end{tabular}')
        latex_code.append('\\end{table}')
        
        return '\n'.join(latex_code)
        
    def create_results_summary(self,
                             results: Dict,
                             output_format: str = 'markdown') -> str:
        """创建结果总结
        
        生成结果摘要的格式化文本。
        
        Args:
            results: 结果数据字典
            output_format: 输出格式 ('markdown'/'latex')
            
        Returns:
            str: 格式化的结果摘要
        """
        if output_format == 'markdown':
            summary = ['# 优化结果摘要\n']
            
            for key, value in results.items():
                summary.append(f'## {key}\n')
                if isinstance(value, (list, np.ndarray)):
                    summary.append('```')
                    summary.append(str(value))
                    summary.append('```\n')
                else:
                    summary.append(f'{value}\n')
                    
            return '\n'.join(summary)
            
        elif output_format == 'latex':
            summary = ['\\section{优化结果摘要}']
            
            for key, value in results.items():
                summary.append(f'\\subsection{{{key}}}')
                if isinstance(value, (list, np.ndarray)):
                    summary.append('\\begin{verbatim}')
                    summary.append(str(value))
                    summary.append('\\end{verbatim}')
                else:
                    summary.append(str(value))
                summary.append('')
                
            return '\n'.join(summary)
            
        else:
            raise ValueError(f'不支持的输出格式: {output_format}')
