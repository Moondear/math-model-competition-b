附录5 多目标优化算法代码
"""
附录5: 多目标优化算法代码 - NSGA-II算法实现

本代码实现了基于NSGA-II的多目标优化算法，用于求解多目标Pareto
最优前沿。包含了非支配排序、拥挤度距离计算、精英选择等核心功能。

作者: [团队成员姓名]
创建时间: 2024-02-20
"""

import numpy as np
from typing import List, Dict, Tuple, Optional
from dataclasses import dataclass
import random
from copy import deepcopy
import matplotlib.pyplot as plt

@dataclass
class Individual:
    """个体类
    
    表示种群中的一个个体，包含决策变量和目标函数值。
    
    属性:
        variables: 决策变量列表
        objectives: 目标函数值列表
        rank: 非支配等级
        crowding_distance: 拥挤度距离
    """
    variables: List[float]
    objectives: List[float]
    rank: int = 0
    crowding_distance: float = 0.0
    
class NSGAII:
    """NSGA-II多目标优化算法
    
    实现了基于NSGA-II的多目标优化算法，支持多个目标函数的
    同时优化，并能找到Pareto最优解集。
    
    属性:
        n_objectives: 目标函数个数
        n_variables: 决策变量个数
        population_size: 种群大小
        n_generations: 迭代代数
        mutation_rate: 变异概率
        crossover_rate: 交叉概率
    """
    
    def __init__(self,
                 n_objectives: int,
                 n_variables: int,
                 population_size: int = 100,
                 n_generations: int = 200,
                 mutation_rate: float = 0.1,
                 crossover_rate: float = 0.9):
        """初始化NSGA-II优化器
        
        Args:
            n_objectives: 目标函数个数
            n_variables: 决策变量个数
            population_size: 种群大小
            n_generations: 迭代代数
            mutation_rate: 变异概率
            crossover_rate: 交叉概率
        """
        self.n_objectives = n_objectives
        self.n_variables = n_variables
        self.population_size = population_size
        self.n_generations = n_generations
        self.mutation_rate = mutation_rate
        self.crossover_rate = crossover_rate
        self.population = []
        self.pareto_front = []
        
    def initialize_population(self):
        """初始化种群
        
        随机生成初始种群个体，并计算其目标函数值。
        """
        self.population = []
        for _ in range(self.population_size):
            # 随机生成决策变量
            variables = np.random.random(self.n_variables)
            # 计算目标函数值
            objectives = self._evaluate_objectives(variables)
            # 创建个体
            individual = Individual(variables=variables,
                                 objectives=objectives)
            self.population.append(individual)
            
    def _evaluate_objectives(self,
                           variables: List[float]) -> List[float]:
        """评估目标函数值
        
        计算给定决策变量下的多个目标函数值。
        
        Args:
            variables: 决策变量列表
            
        Returns:
            list: 目标函数值列表
        """
        # 示例目标函数
        f1 = sum(x**2 for x in variables)  # 最小化总成本
        f2 = -np.prod([x+1 for x in variables])  # 最大化总利润
        f3 = max(variables)  # 最小化最大风险
        
        return [f1, f2, f3]
        
    def fast_non_dominated_sort(self,
                              population: List[Individual]) -> List[List[Individual]]:
        """快速非支配排序
        
        将种群划分为不同的非支配等级。
        
        Args:
            population: 待排序的种群
            
        Returns:
            list: 不同等级的个体列表
        """
        fronts = [[]]  # 存储不同等级的个体
        
        # 初始化每个个体的支配计数和被支配个体集合
        for p in population:
            p.domination_count = 0  # 支配p的个体数量
            p.dominated_solutions = []  # p支配的个体列表
            
            for q in population:
                if p != q:
                    # 检查p是否支配q
                    if self._dominates(p, q):
                        p.dominated_solutions.append(q)
                    # 检查q是否支配p
                    elif self._dominates(q, p):
                        p.domination_count += 1
                        
            # 如果p不被任何个体支配，则属于第一等级
            if p.domination_count == 0:
                p.rank = 0
                fronts[0].append(p)
                
        # 生成其他等级的前沿
        i = 0
        while fronts[i]:
            next_front = []
            # 对当前等级的每个个体
            for p in fronts[i]:
                # 检查其支配的个体
                for q in p.dominated_solutions:
                    q.domination_count -= 1
                    # 如果q不再被其他个体支配，则进入下一等级
                    if q.domination_count == 0:
                        q.rank = i + 1
                        next_front.append(q)
            i += 1
            if next_front:
                fronts.append(next_front)
                
        return fronts
        
    def calculate_crowding_distance(self,
                                  front: List[Individual]):
        """计算拥挤度距离
        
        计算同一等级内个体的拥挤度距离。
        
        Args:
            front: 同一等级的个体列表
        """
        if len(front) <= 2:
            for individual in front:
                individual.crowding_distance = float('inf')
            return
            
        # 初始化距离
        for individual in front:
            individual.crowding_distance = 0
            
        # 对每个目标函数
        for m in range(self.n_objectives):
            # 根据第m个目标函数值排序
            front.sort(key=lambda x: x.objectives[m])
            
            # 边界点的距离设为无穷大
            front[0].crowding_distance = float('inf')
            front[-1].crowding_distance = float('inf')
            
            # 计算中间点的距离
            f_max = front[-1].objectives[m]
            f_min = front[0].objectives[m]
            
            if f_max != f_min:
                for i in range(1, len(front)-1):
                    front[i].crowding_distance += (
                        front[i+1].objectives[m] -
                        front[i-1].objectives[m]
                    ) / (f_max - f_min)
                    
    def _dominates(self,
                  p: Individual,
                  q: Individual) -> bool:
        """检查个体p是否支配个体q
        
        对所有目标函数，p都不差于q，且至少一个目标函数更优。
        
        Args:
            p, q: 待比较的两个个体
            
        Returns:
            bool: 如果p支配q则返回True
        """
        better_in_any = False
        for i in range(self.n_objectives):
            if p.objectives[i] > q.objectives[i]:
                return False
            elif p.objectives[i] < q.objectives[i]:
                better_in_any = True
                
        return better_in_any
        
    def tournament_selection(self,
                           population: List[Individual],
                           tournament_size: int = 2) -> Individual:
        """锦标赛选择
        
        从种群中选择优秀个体。
        
        Args:
            population: 种群列表
            tournament_size: 锦标赛规模
            
        Returns:
            Individual: 选中的个体
        """
        tournament = random.sample(population, tournament_size)
        best = tournament[0]
        
        for individual in tournament[1:]:
            if (individual.rank < best.rank or
                (individual.rank == best.rank and
                 individual.crowding_distance > best.crowding_distance)):
                best = individual
                
        return deepcopy(best)
        
    def crossover(self,
                 parent1: Individual,
                 parent2: Individual) -> Tuple[Individual, Individual]:
        """交叉操作
        
        对两个父代个体进行模拟二进制交叉(SBX)。
        
        Args:
            parent1, parent2: 父代个体
            
        Returns:
            tuple: 两个子代个体
        """
        child1 = deepcopy(parent1)
        child2 = deepcopy(parent2)
        
        if random.random() < self.crossover_rate:
            for i in range(self.n_variables):
                if random.random() < 0.5:
                    child1.variables[i], child2.variables[i] = \
                        child2.variables[i], child1.variables[i]
                        
        # 重新计算目标函数值
        child1.objectives = self._evaluate_objectives(child1.variables)
        child2.objectives = self._evaluate_objectives(child2.variables)
        
        return child1, child2
        
    def mutate(self, individual: Individual):
        """变异操作
        
        对个体进行多项式变异。
        
        Args:
            individual: 待变异的个体
        """
        mutated = False
        for i in range(self.n_variables):
            if random.random() < self.mutation_rate:
                mutated = True
                # 在[0,1]范围内变异
                delta = random.gauss(0, 0.1)
                individual.variables[i] = np.clip(
                    individual.variables[i] + delta,
                    0, 1
                )
                
        if mutated:
            # 重新计算目标函数值
            individual.objectives = self._evaluate_objectives(
                individual.variables
            )
            
    def optimize(self) -> List[Individual]:
        """执行NSGA-II优化
        
        运行完整的NSGA-II算法流程。
        
        Returns:
            list: Pareto最优解集
        """
        # 初始化种群
        self.initialize_population()
        
        for generation in range(self.n_generations):
            # 生成子代种群
            offspring = []
            while len(offspring) < self.population_size:
                # 选择父代
                parent1 = self.tournament_selection(self.population)
                parent2 = self.tournament_selection(self.population)
                
                # 交叉
                child1, child2 = self.crossover(parent1, parent2)
                
                # 变异
                self.mutate(child1)
                self.mutate(child2)
                
                offspring.extend([child1, child2])
                
            # 合并父代和子代
            combined_pop = self.population + offspring
            
            # 非支配排序
            fronts = self.fast_non_dominated_sort(combined_pop)
            
            # 生成下一代种群
            new_population = []
            for front in fronts:
                if len(new_population) + len(front) <= self.population_size:
                    # 计算拥挤度距离
                    self.calculate_crowding_distance(front)
                    new_population.extend(front)
                else:
                    # 计算拥挤度距离
                    self.calculate_crowding_distance(front)
                    # 根据拥挤度距离排序
                    front.sort(key=lambda x: x.crowding_distance, reverse=True)
                    # 选择需要的个体数量
                    new_population.extend(
                        front[:self.population_size-len(new_population)]
                    )
                    break
                    
            self.population = new_population
            
            # 更新Pareto前沿
            self.pareto_front = fronts[0]
            
            # 输出进度
            if (generation + 1) % 10 == 0:
                print(f"Generation {generation + 1}/{self.n_generations}")
                self._print_metrics()
                
        return self.pareto_front
        
    def _print_metrics(self):
        """打印优化指标
        
        输出当前种群的优化指标。
        """
        # 计算超体积指标
        hypervolume = self._calculate_hypervolume()
        # 计算分布指标
        spread = self._calculate_spread()
        
        print(f"Hypervolume: {hypervolume:.4f}")
        print(f"Spread: {spread:.4f}")
        print("-" * 40)
        
    def _calculate_hypervolume(self) -> float:
        """计算超体积指标
        
        计算Pareto前沿的超体积指标，用于评估收敛性和多样性。
        
        Returns:
            float: 超体积指标值
        """
        # 简化版本的超体积计算
        if not self.pareto_front:
            return 0.0
            
        reference_point = [1.1 * max(ind.objectives[i]
                                   for ind in self.pareto_front)
                          for i in range(self.n_objectives)]
                          
        volume = 0.0
        for ind in self.pareto_front:
            volume += np.prod([reference_point[i] - ind.objectives[i]
                             for i in range(self.n_objectives)])
                             
        return volume
        
    def _calculate_spread(self) -> float:
        """计算分布指标
        
        计算Pareto前沿的分布指标，评估解的分布均匀性。
        
        Returns:
            float: 分布指标值
        """
        if len(self.pareto_front) < 3:
            return float('inf')
            
        distances = []
        for i in range(len(self.pareto_front)-1):
            dist = np.linalg.norm(
                [self.pareto_front[i].objectives[j] -
                 self.pareto_front[i+1].objectives[j]
                 for j in range(self.n_objectives)]
            )
            distances.append(dist)
            
        # 计算平均距离
        d_avg = np.mean(distances)
        # 计算极端解的距离
        d_extremes = np.linalg.norm(
            [self.pareto_front[0].objectives[j] -
             self.pareto_front[-1].objectives[j]
             for j in range(self.n_objectives)]
        )
        
        # 计算分布指标
        spread = (d_extremes +
                 sum(abs(d - d_avg) for d in distances)) / \
                (d_extremes + len(distances) * d_avg)
                
        return spread
        
    def visualize_pareto_front(self,
                              save_path: Optional[str] = None):
        """可视化Pareto前沿
        
        生成2D或3D的Pareto前沿可视化图表。
        
        Args:
            save_path: 图像保存路径
        """
        if self.n_objectives == 2:
            self._plot_2d_pareto(save_path)
        elif self.n_objectives == 3:
            self._plot_3d_pareto(save_path)
        else:
            print("只支持2D或3D的Pareto前沿可视化")
            
    def _plot_2d_pareto(self, save_path: Optional[str] = None):
        """绘制2D Pareto前沿"""
        plt.figure(figsize=(10, 6))
        
        # 绘制所有解
        objectives = np.array([ind.objectives for ind in self.population])
        plt.scatter(objectives[:, 0], objectives[:, 1],
                   c='lightgray', label='可行解')
                   
        # 绘制Pareto前沿
        pareto_obj = np.array([ind.objectives for ind in self.pareto_front])
        plt.scatter(pareto_obj[:, 0], pareto_obj[:, 1],
                   c='red', label='Pareto前沿')
                   
        plt.xlabel('目标函数1')
        plt.ylabel('目标函数2')
        plt.title('二维Pareto前沿')
        plt.legend()
        plt.grid(True)
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        plt.close()
        
    def _plot_3d_pareto(self, save_path: Optional[str] = None):
        """绘制3D Pareto前沿"""
        fig = plt.figure(figsize=(12, 8))
        ax = fig.add_subplot(111, projection='3d')
        
        # 绘制所有解
        objectives = np.array([ind.objectives for ind in self.population])
        ax.scatter(objectives[:, 0], objectives[:, 1], objectives[:, 2],
                  c='lightgray', label='可行解')
                  
        # 绘制Pareto前沿
        pareto_obj = np.array([ind.objectives for ind in self.pareto_front])
        ax.scatter(pareto_obj[:, 0], pareto_obj[:, 1], pareto_obj[:, 2],
                  c='red', label='Pareto前沿')
                  
        ax.set_xlabel('目标函数1')
        ax.set_ylabel('目标函数2')
        ax.set_zlabel('目标函数3')
        ax.set_title('三维Pareto前沿')
        plt.legend()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        plt.close()
